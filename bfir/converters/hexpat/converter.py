#!/usr/bin/env python
"""
BFIR to HexPat Converter

This module converts Binary Format Intermediate Representation (BFIR) JSON
to ImHex pattern language (.hexpat) files.

The converter is designed to be:
1. Modular and maintainable
2. Handle all aspects of the BFIR schema
3. Generate valid HexPat syntax
4. Include proper error handling and validation
"""

import json
import re
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional, Set


class BFIRToHexPatConverter:
    """Converts Binary Format IR to ImHex pattern language."""

    def __init__(
        self, bfir_data: Dict[str, Any], options: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize with BFIR data and optional conversion options.

        Args:
            bfir_data: The BFIR JSON data as a dictionary
            options: Optional configuration for the conversion process
        """
        self.bfir = bfir_data
        self.options = options or {}
        # Track processed fields to avoid duplicates
        self.processed_fields = set()
        # Track required library imports
        self.required_libraries: Set[str] = set()

    def convert(self) -> str:
        """
        Convert BFIR to HexPat.

        Returns:
            A string containing the complete HexPat template
        """
        lines = []

        # Add header and metadata
        lines.extend(self._generate_header())

        # Add pragma statements
        lines.extend(self._generate_pragmas())

        # Add library imports if needed
        lines.extend(self._generate_library_imports())

        # Generate forward declarations for all struct types
        lines.extend(self._generate_forward_declarations())

        # First pass: Generate all struct type definitions
        # This ensures all types are defined before they're used
        lines.extend(self._generate_type_definitions())

        # Second pass: Generate the main struct
        lines.extend(self._generate_main_struct())

        # Add placement at offset
        lines.extend(self._generate_placement())

        return "\n".join(lines)

    def _generate_header(self) -> List[str]:
        """Generate header comments."""
        format_info = self.bfir.get("format", {})
        format_name = format_info.get("name", "Unknown Format")
        format_version = format_info.get("version", "")
        format_desc = format_info.get("description", "")

        lines = [
            f"// {format_name} Pattern for ImHex",
            f"// Format Version: {format_version}",
            "// Generated by BFIR to HexPat Converter",
            "//",
        ]

        if format_desc:
            lines.append(f"// Description: {format_desc}")

        lines.append("")
        return lines

    def _generate_pragmas(self) -> List[str]:
        """Generate pragma statements."""
        format_info = self.bfir.get("format", {})
        endianness = format_info.get("endianness", "little")

        lines = [f"#pragma endian {endianness}", ""]
        return lines

    def _generate_library_imports(self) -> List[str]:
        """Generate library import statements for required libraries."""
        lines = []
        
        # Add imports for any libraries identified during processing
        for library in sorted(self.required_libraries):
            lines.append(f"import {library};")
        
        if lines:
            lines.append("")
        
        return lines

    def _generate_forward_declarations(self) -> List[str]:
        """Generate forward declarations for all struct types."""
        lines = []
        fields = self.bfir.get("fields", [])
        
        # Collect all struct fields that need forward declarations
        struct_fields = [f for f in fields if f.get("type") in ["struct", "bit_fields"]]
        
        # Add forward declarations using the 'using' syntax
        for field in struct_fields:
            field_name = field.get("name", "Unknown")
            struct_name = self._sanitize_identifier(field_name)
            lines.append(f"using {struct_name};")
        
        if lines:
            lines.append("")
        
        return lines

    def _generate_type_definitions(self) -> List[str]:
        """Generate all struct and enum type definitions."""
        lines = []
        fields = self.bfir.get("fields", [])

        # First pass: collect all enum fields
        enum_fields = [f for f in fields if f.get("type") == "enum" and "enum_values" in f]

        # Generate enum definitions
        for field in enum_fields:
            enum_def = self._generate_enum_definition(field)
            if enum_def:
                lines.extend(enum_def)
                lines.append("")

        # Second pass: collect all struct fields that need type definitions
        struct_fields = [f for f in fields if f.get("type") in ["struct", "bit_fields"]]

        # Create a dependency graph for struct fields
        dependency_graph = {}
        for field in struct_fields:
            field_id = field.get("id", "")
            dependencies = []

            # If this is a struct, find all its children
            if field.get("type") == "struct":
                children = [f for f in fields if f.get("parent") == field_id]
                for child in children:
                    # If the child is a struct or bit_fields, add it as a dependency
                    if child.get("type") in ["struct", "bit_fields"]:
                        dependencies.append(child.get("id", ""))

            dependency_graph[field_id] = dependencies

        # Topologically sort the struct fields based on dependencies
        # This ensures that types are defined before they're used
        sorted_field_ids = self._topological_sort(dependency_graph)

        # Generate struct definitions in the sorted order
        for field_id in sorted_field_ids:
            field = next((f for f in struct_fields if f.get("id") == field_id), None)
            if field:
                struct_def = self._generate_struct_type_definition(field, fields)
                if struct_def:
                    lines.extend(struct_def)
                    lines.append("")

        return lines

    def _topological_sort(self, graph: Dict[str, List[str]]) -> List[str]:
        """
        Perform a topological sort on the dependency graph.
        This ensures that dependencies are defined before they're used.
        """
        # Initialize the result list and visited set
        result = []
        visited = set()
        temp_visited = set()

        def visit(node):
            if node in temp_visited:
                # Circular dependency detected, break the cycle
                return
            if node in visited:
                return

            temp_visited.add(node)

            # Visit all dependencies first
            for dependency in graph.get(node, []):
                visit(dependency)

            temp_visited.remove(node)
            visited.add(node)
            result.append(node)

        # Visit each node in the graph
        for node in graph:
            if node not in visited:
                visit(node)

        # Reverse the result to get the correct order
        # (dependencies first, then dependents)
        return list(reversed(result))

    def _generate_enum_definition(self, field: Dict[str, Any]) -> List[str]:
        """Generate enum definition."""
        field_id = field.get("id", "")
        field_name = field.get("name", "Unknown")
        enum_values = field.get("enum_values", {})

        if not enum_values:
            return []

        # Create a valid identifier for the enum
        enum_name = self._sanitize_identifier(field_name) + "_enum"

        # Determine the enum type based on the max value
        max_value = max(enum_values.values()) if enum_values else 0
        if max_value <= 255:
            enum_type = "u8"
        elif max_value <= 65535:
            enum_type = "u16"
        else:
            enum_type = "u32"

        lines = [f"enum {enum_name} : {enum_type} {{"]

        # Add each enum value
        for name, value in enum_values.items():
            value_name = self._sanitize_identifier(name)
            lines.append(f"    {value_name} = {value},")

        lines.append("};")

        # Mark this field as processed
        self.processed_fields.add(field_id)

        return lines

    def _generate_struct_type_definition(self, field: Dict[str, Any], all_fields: List[Dict[str, Any]]) -> List[str]:
        """Generate a struct type definition."""
        field_id = field.get("id", "")
        field_name = field.get("name", "Unknown")
        field_desc = field.get("description", "")
        field_type = field.get("type", "")

        # Skip if already processed
        if field_id in self.processed_fields:
            return []

        # Mark as processed
        self.processed_fields.add(field_id)

        lines = []

        # Add comment if available
        if field_desc:
            lines.append(f"// {field_desc}")

        # Handle different struct types
        if field_type == "bit_fields":
            # Generate bit field struct
            lines.extend(self._generate_bit_field(field))
        elif field_type == "struct":
            # Generate struct with children
            struct_name = self._sanitize_identifier(field_name)
            lines.append(f"struct {struct_name} {{")
            
            # Find all children of this field
            children = [f for f in all_fields if f.get("parent") == field_id]
            
            # Generate each child field
            for child in children:
                child_def = self._generate_field_definition(child, all_fields)
                if child_def:
                    lines.extend(["    " + line for line in child_def])
            
            lines.append("};")
        
        return lines

    def _generate_bit_field(self, field: Dict[str, Any]) -> List[str]:
        """Generate a bit field struct definition."""
        field_name = field.get("name", "Unknown")
        field_desc = field.get("description", "")
        bit_fields = field.get("bit_fields", [])
        
        lines = []
        
        # Add comment for the struct if available
        if field_desc:
            lines.append(f"// {field_desc}")
        
        # Start bitfield definition
        struct_name = self._sanitize_identifier(field_name)
        lines.append(f"bitfield {struct_name} {{")
        
        # Add bit fields
        for bit_field in bit_fields:
            bit_name = bit_field.get("name", "Unknown")
            bit_desc = bit_field.get("description", "")
            bits = bit_field.get("bits", 1)
            
            # Generate the bit field line
            field_line = f"    {self._sanitize_identifier(bit_name.lower())} : {bits};"
            
            # Add comment if available
            if bit_desc:
                field_line += f"  // {bit_desc}"
            
            lines.append(field_line)
        
        # Close struct
        lines.append("};")
        lines.append("")
        
        return lines

    def _generate_field_definition(self, field: Dict[str, Any], all_fields: List[Dict[str, Any]]) -> List[str]:
        """Generate a field definition for use inside a struct."""
        field_name = field.get("name", "Unknown")
        field_desc = field.get("description", "")
        field_type = field.get("type", "simple_value")
        field_offset = field.get("offset", "")

        # Handle different field types
        if field_type == "bit_fields":
            # Use the bit field struct type
            struct_name = self._sanitize_identifier(field_name)
            field_def = f"{struct_name} {self._sanitize_identifier(field_name.lower())};"
            
            # Add comment if available
            if field_desc:
                field_def += f"  // {field_desc}"
            
            # Add offset comment if available
            if field_offset and not field_desc:
                field_def += f"  // {field_offset}"
            elif field_offset:
                field_def += f" {field_offset}"
            
            return [field_def]
        elif field_type == "struct":
            # Use the struct type
            struct_name = self._sanitize_identifier(field_name)
            field_def = f"{struct_name} {self._sanitize_identifier(field_name.lower())};"
            
            # Add comment if available
            if field_desc:
                field_def += f"  // {field_desc}"
            
            # Add offset comment if available
            if field_offset and not field_desc:
                field_def += f"  // {field_offset}"
            elif field_offset:
                field_def += f" {field_offset}"
            
            return [field_def]
        elif field_type == "enum":
            # Use the enum type
            enum_name = self._sanitize_identifier(field_name) + "_enum"
            field_def = f"{enum_name} {self._sanitize_identifier(field_name.lower())};"
            
            # Add comment if available
            if field_desc:
                field_def += f"  // {field_desc}"
            
            # Add offset comment if available
            if field_offset and not field_desc:
                field_def += f"  // {field_offset}"
            elif field_offset:
                field_def += f" {field_offset}"
            
            return [field_def]
        else:
            # Generate a simple field
            return self._generate_simple_field(field)

    def _generate_simple_field(self, field: Dict[str, Any]) -> List[str]:
        """Generate a simple field definition."""
        field_name = field.get("name", "Unknown")
        field_desc = field.get("description", "")
        field_size = field.get("size", 1)
        field_type = field.get("type", "simple_value")
        field_offset = field.get("offset", "")
        field_array_size = field.get("array_size", None)
        
        # Handle fixed_pattern type
        if field_type == "fixed_pattern":
            # For fixed patterns, use u8 array
            field_def = f"u8 {self._sanitize_identifier(field_name.lower())}[{field_size}];"
        else:
            # Determine the field type based on size
            if field_type == "simple_value":
                if field_size == 1:
                    type_name = "u8"
                elif field_size == 2:
                    type_name = "u16"
                elif field_size == 4:
                    type_name = "u32"
                elif field_size == 8:
                    type_name = "u64"
                else:
                    type_name = f"u8[{field_size}]"
            else:
                # Use the field type as is
                type_name = field_type
            
            # Generate the field line
            if field_array_size:
                field_def = f"{type_name} {self._sanitize_identifier(field_name.lower())}[{field_array_size}];"
            else:
                field_def = f"{type_name} {self._sanitize_identifier(field_name.lower())};"
        
        # Add comment if available
        if field_desc:
            field_def += f"  // {field_desc}"
        
        # Add offset comment if available
        if field_offset and not field_desc:
            field_def += f"  // {field_offset}"
        elif field_offset:
            field_def += f" {field_offset}"
        
        return [field_def]

    def _generate_for_loop(self, init_var: str, init_value: int, 
                          condition: str, increment: str, 
                          body_lines: List[str]) -> List[str]:
        """
        Generate a for loop with the correct ImHex syntax.
        
        Args:
            init_var: The loop variable name
            init_value: The initial value for the loop variable
            condition: The loop condition
            increment: The increment expression
            body_lines: The lines of code in the loop body
            
        Returns:
            List of strings containing the formatted for loop
        """
        # ImHex uses commas instead of semicolons in for loops
        loop_header = f"for ({init_var} = {init_value}, {condition}, {increment}) {{"
        
        # Indent the body lines
        indented_body = ["    " + line for line in body_lines]
        
        # Close the loop
        loop_footer = "}"
        
        return [loop_header] + indented_body + [loop_footer]
    
    def _generate_function_call(self, namespace: str, function: str, 
                               args: List[str]) -> str:
        """
        Generate a function call with the correct ImHex namespace syntax.
        
        Args:
            namespace: The library namespace (e.g., 'std.math')
            function: The function name
            args: The function arguments
            
        Returns:
            String containing the formatted function call
        """
        # Convert dot notation in namespace to double colon notation for function calls
        namespace_parts = namespace.split('.')
        namespace_call = "::".join(namespace_parts)
        
        # Add the library to required imports if not already present
        self.required_libraries.add(namespace)
        
        # Format the function call
        args_str = ", ".join(args)
        return f"{namespace_call}::{function}({args_str})"

    def _generate_function_declaration(self, function_name: str, params: List[Dict[str, str]], 
                                      body_lines: List[str], return_type: str = None) -> List[str]:
        """
        Generate a function declaration with the correct ImHex syntax.
        
        Args:
            function_name: The name of the function
            params: List of parameter dictionaries with 'name' and 'type' keys
            body_lines: The lines of code in the function body
            return_type: Optional return type (ImHex infers return type if not specified)
            
        Returns:
            List of strings containing the formatted function declaration
        """
        # Format parameters
        param_strs = []
        for param in params:
            param_strs.append(f"{param['type']} {param['name']}")
        
        params_str = ", ".join(param_strs)
        
        # Start function declaration
        if return_type:
            header = f"fn {function_name}({params_str}) -> {return_type} {{"
        else:
            header = f"fn {function_name}({params_str}) {{"
        
        # Indent the body lines
        indented_body = ["    " + line for line in body_lines]
        
        # Close the function with semicolon (important in ImHex pattern language)
        footer = "};"
        
        return [header] + indented_body + [footer, ""]

    def _generate_main_struct(self) -> List[str]:
        """Generate the main struct definition."""
        format_info = self.bfir.get("format", {})
        format_name = format_info.get("name", "Unknown")
        struct_name = self._sanitize_identifier(format_name)

        lines = [f"struct {struct_name} {{"]

        # Get top-level fields (those without a parent)
        fields = self.bfir.get("fields", [])
        top_level_fields = [f for f in fields if not f.get("parent")]

        # Generate field definitions
        for field in top_level_fields:
            field_def = self._generate_field_definition(field, fields)
            if field_def:
                lines.extend(["    " + line for line in field_def])

        lines.append("};")
        lines.append("")

        return lines

    def _generate_placement(self) -> List[str]:
        """Generate placement at offset."""
        format_info = self.bfir.get("format", {})
        format_name = format_info.get("name", "Unknown")
        struct_name = self._sanitize_identifier(format_name)

        lines = [f"{struct_name} {struct_name.lower()} @ 0x00;"]

        return lines

    def _sanitize_identifier(self, name: str) -> str:
        """Convert a field name to a valid HexPat identifier."""
        # Replace spaces and special characters with underscores
        identifier = re.sub(r"[^a-zA-Z0-9_]", "_", name)
        # Ensure it starts with a letter
        if not identifier or not identifier[0].isalpha():
            identifier = "f_" + identifier
        # Convert to camelCase
        words = identifier.split("_")
        identifier = words[0].lower() + "".join(word.capitalize() for word in words[1:])
        return identifier


def convert_file(
    input_file: str, output_file: str, options: Optional[Dict[str, Any]] = None
) -> bool:
    """
    Convert a BFIR JSON file to a HexPat file.

    Args:
        input_file: Path to the input BFIR JSON file
        output_file: Path to the output HexPat file
        options: Optional configuration for the conversion process

    Returns:
        True if conversion was successful, False otherwise
    """
    try:
        # Load BFIR JSON
        with open(input_file, "r", encoding="utf-8") as f:
            bfir_data = json.load(f)

        # Create converter
        converter = BFIRToHexPatConverter(bfir_data, options)

        # Convert to HexPat
        hexpat_content = converter.convert()

        # Save HexPat file
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(hexpat_content)

        print(f"Successfully converted {input_file} to {output_file}")
        return True

    except Exception as e:
        print(f"Error converting {input_file}: {e}")
        return False


def main():
    """Command-line entry point."""
    if len(sys.argv) < 3:
        print("Usage: python converter.py <input_bfir.json> <output.hexpat>")
        return 1

    input_file = sys.argv[1]
    output_file = sys.argv[2]

    success = convert_file(input_file, output_file)
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
